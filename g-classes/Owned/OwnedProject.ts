// Generated by https://quicktype.io
import { OwnedUser } from "./OwnedUser";
import { TypeErr } from "../../g-utils/errors";
import { ProjectUpdate, OwnedProjectProps } from "./OwnedInterfaces"
import { UserProps } from "../Public/PublicInterfaces"

import axios from "axios"
import { EventEmitter } from "events";

function updateClass(project: OwnedProject, data: OwnedProjectProps) : void {
    project.deleted = false;
    function propsToDate(props: string[], path?: string) : void {
        for(let prop of props) {
            if(typeof prop == "string") {
                if(props[path]) project[String(path)][String(prop)] = new Date(project[String(path)][String(prop)]);
                else project[String(prop)] = new Date(project[String(prop)]);
            }
        }
    }
    const emailEntries = Object.entries(data);
    // Set properties of class
    for(let x: number = 0; x < emailEntries.length; x++) {
        project[emailEntries[x][0]] = emailEntries[x][1];
    }

    // Make date strings dates
    propsToDate([
        "createdAt",
        "updatedAt",
        "deletedAt",
        "suspendedAt",
        "lastAccess",
        "avatarUpdatedAt",
        "archivedAt",
        "visitsLastBackfilledAt"
    ])
    propsToDate([
        "userLastAccess",
        "createdAt",
        "updatedAt"
    ], "permission")
}

function reloadProject(id: string, token: string, deleted?: boolean) : Promise<OwnedProjectProps> {
    return new Promise((res, rej) => {
        let URI: string;
        if(deleted) {
            URI = `https://api.glitch.com/projects/${id}?showDeleted=true`
        } else {
            URI = `https://api.glitch.com/projects/${id}`
        }
        axios.get<OwnedProjectProps>(URI, {
            headers: { Authorization: token }
        }).catch(e => {
            rej(e);
        }).then(req => {
            if(!req) return rej("Request Failed.");
            res(!deleted ? req.data : req.data[id])
        })
    })
}

export class OwnedProject extends EventEmitter implements OwnedProjectProps {
    id:                     string;
    inviteToken:            string;
    description:            string;
    domain:                 string;
    baseId:                 string;
    private:                boolean;
    createdAt:              Date;
    updatedAt:              Date;
    deletedAt:              Date;
    likesCount:             number;
    suspendedAt:            Date;
    suspendedReason:        string;
    lastAccess:             Date;
    avatarUpdatedAt:        Date;
    numEditorVisits:        number;
    numAppVisits:           number;
    visitsLastBackfilledAt: string;
    showAsGlitchTeam:       boolean;
    evicted:                boolean;
    isEmbedOnly:            boolean;
    remixChain:             string[];
    notSafeForKids:         boolean;
    firmlyDeleted:          null;
    archivedAt:             Date;
    teamsProjects:          any[];
    users:                  UserProps[];
    teams:                  any[];
    projectCnames:          any[];
    owner:                  OwnedUser;
    deleted:                boolean;

    constructor(owner: OwnedUser, data?: OwnedProjectProps) {
        super();
        this.owner = owner;
        if(typeof data == "object") updateClass(this, data);
    }
    update(options: ProjectUpdate) : Promise<OwnedProject> {
        return new Promise((res, rej) => {
            if(typeof options != "object") rej(TypeErr("options", "object", typeof options));
            if(Object.keys(options).length == 0) rej(new Error(`Argument "options" object empty.`));
            axios.patch(`https://api.glitch.com/v1/projects/${this.id}`, options,
            {
                headers: { Authorization: this.owner.persistentToken }
            })
            .catch(e => {
                rej(e);
            })
            .then(req => {
                this.reload().catch(e => { rej(e); }).then(_ => {
                    res(this);
                });
            })
        })
    }
    delete() : Promise<OwnedProject> {
        return new Promise((res, rej) => {
            axios.delete(`https://api.glitch.com/v1/projects/${this.id}`,
            {
                headers: { Authorization: this.owner.persistentToken }
            })
            .catch(e => {
                rej(e);
            }).then(_ => {
                this.deleted = true;
                this.reload().then(_ => {
                    res(this);
                });
                
            })
            
        })
    }
    reload() : Promise<OwnedProject> {
        return new Promise((res, rej) => {
            reloadProject(this.id, this.owner.persistentToken, this.deleted)
            .then(p => {
                updateClass(this, p);
                res(this);
            }).catch(e => rej(e));
        })
    }
    undelete() {
        return new Promise((res, rej) => {
            if(this.deleted) {
                axios.post(`https://api.glitch.com/v1/projects/${this.id}/undelete`)
                .catch(e => {
                    rej(e);
                }).then(_ => {
                    this.reload()
                    .then(_ => {
                        res(this);
                    }).catch(e => rej(e));
                })
            } else rej("Project is not deleted.");
        })
    }
    find(id: string) {
        reloadProject(id, this.owner.persistentToken).then(r => {
            updateClass(this, r);
            this.emit("ready");
        })
    }
}

exports = OwnedProject;